# 图
图：表现的是对象集合以及其间关系的集合
图里的对象称为结点“Node”或顶点（Vertex）,通常用圆来表示。“关系”表示顶点和顶点之间的关系，称为边(Edge)。圆与圆之间的关系用连线或箭头表示。
## 图的分类
1. 无向图      边没有方向的图
2. 有向图      边有方向的图
3. 加权无向图    边有权值但没有方向的图
4. 加权有向图     边有权值且有方向的图

## 图的表述与术语
顶点集合为V，边集合为E的图记作G=(V,E)。另外，G=(V,E)的顶点数和边数分为|V|和|E|。
  
  连接两个顶点的边记作e=(u,v)。在无向图中，(u,v)和(v,u)代表同一条边。在加权图中，边(u,v)的权记作w(u,v)。

如果无向图中存在边（u,v），我们就称顶点u和顶点v相邻(Adjacent).相邻顶点的序列v0,v1,...,vk(对于所有i=1,2,....,)，k存在边(vi-1,vi)称为路径(path)。起点和终点的路劲称为环(Cycle)

不存在环的有向图称为Directed Acyclic Graph(DAG)。

与顶点u相连的边数为顶点u的度（Degree）。在有向图中，以顶点u为终点的边数称为顶点u的入度，以顶点u为起点的边数称为顶点u的出度。

如果对图G=(V,E)而言，任意两个顶点u,v都存在从u到v的路径，那么G称为连通图。

对于两个图G1和G2,如果G2的顶点集合与边集合皆为G的顶点集合与边集合的子集，那么G2就称为G的子图。

## 图的基本算法
***图最基本的算法是搜索。***
最具有代表性的搜索算法是深度优先搜索(Depth FIrst Seatch,DFS)和广度优先搜索（Breadth Firth Search,BFS）。

## 图的表示
1. 邻接表(Adjacency List)  
我们对V的每个顶点都用一个表来表示，总计用|V|(总的顶点个数)来表示图。
对于顶点u,邻接表Adj[u]中包含所有与(u,vi)相连的顶点vi。也就是说，Adj[u]由G中
所有与u相邻的顶点构成
2. 邻接矩阵(Adjacency Matrices)
用|v|*|v|的矩阵来表示图，其中如果顶点i存在到顶点边，那么aij为1，否则为0.

## 加权图
### 最小生成树
  **树是没有环的图。** 在树中，任意顶点r和顶点v之间必然存在着
  1条路径。  
  图G=（V,E）的生成树（Spanning Tree）G = （V',E'）是图G的子图，它拥有图G所有的顶点，且在保证自身为树的前提下拥有尽可能多的边。图的生成树可通过DFS或BFS求得，且结果不唯一。

  最小生成树（Minimum Spanning Tree）是指各边权值总和最小的生成树。

  #### 最短路径
   在加权图G=(V,E)中，求给定s,d之间各边权值总和最小的路径，这就是最短路径（Shortest Path Problem）。这个问题主要分两类  ：
   1. 单源最短路径（Single Source Shortest Path,SSSP） 。求给定顶点s到其他所有顶点d之间的最短路径
   2. 全点对间最短路径（All Paris Shortest Path,APSP）。在图G中，求“每一对顶点”之间的最短路径。  
  
 #### 最短路径生成树
 对于各边权值非负的加权图G=(V,E)，如果顶点s到G的所有顶点都存在路径，那么一定存在一颗以s为根，包含s到G所有顶点最短路径的生成树T。这种树就称为最短路径生成树（Shortest Path Spanning Tree）。

 #### 普里姆算法
  设图G=(V,E)所有顶点的集合为V，MST中顶点的集合为T
  1. 从G中选取任意顶点作为MST的根，将其添加至T。
  2. 循环执行下述处理直至T = V；  
  ---->在连接T内顶点与V-T内顶点的边中选取权值最小的边，将其作为MST的边，并将MST的边添加至T

 #### 单源最短路径
 * 狄克斯特拉算法（Dijkstra's Algorithm）:   
 设图G=(V,E)所有顶点的集合为V，起点为s,最短路径树中包含的顶点集合为S。在各计算步骤中，我们将选出最短路径树的边和顶点并将其添加至S。  
 对于各顶点i，设仅经由S内顶点的s到i的最短路径成本为d[i],i在最短路径树中的父节点p[i]。
 1. 初始状态下将S置空。
   初始化s的d[s] = 0；除s外,所有属于V的顶点的i的d[i] = 无穷大。
 2. 循环进行以下处理，直至S=V；  
   (1). 从V-S中选出d[u]最小的顶点u;  
   (2). 将u添加至s,同时将与u相邻的所有顶点v的值按照下述方式更新：  
   if(d[u] + w(u,v) < d[v]){   
     d[v] = d[u] + w(u,v);   
     p[v] = u;
   }
  * 优先级队列（邻接表）实现  
  1. 初始状态下将S置空。
    初始化s的d[s] = 0;除s以外，所有属于V的顶点的i的d[i] = 无穷大。  
    以d[i]为键值，将V的顶点建成最小堆H。
  2. 循环处理进行下述处理，直至S = V为止。
    （1）. 从H中取出d[u]最小的顶点但u
     (2). 将u添加S,同时将与u相邻且属于V-S的所有顶点v的值按照下述方式更新。
```
if(d[u] + w(u,v) < d[u]){
    d[v] = d[u] + w(u,v);
    p[v] = u;
    以v为起点更新堆H。
}
```


 